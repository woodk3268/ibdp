
# 1) 카운트를 10씩 증가시키는 예제에서, 더블클릭하면 UI에서 0 -> 10 -> 20으로 2번 변경되는지? 0 ->20으로 1번 변경되는지

**"원칙적으로 2번 변경됨. 1번만 변경하고 싶을 때는 코드 수정해서 구현 가능"**
``
##### i) `dispatch`는 기본적으로 **동기(synchronous)**

- Redux 공식 튜토리얼:  
    “스토어는 **동기적으로** 액션을 디스패치하고, 루트 리듀서를 호출해 상태를 갱신하고, UI에 변경되었음을 알림"

##### ii) 구독자 통지는 **리듀서가 새 상태를 반환한 뒤** 실행

- Redux Store API:  
    “Redux에서는 **루트 리듀서가 새 상태를 반환한 다음** 구독자(subscriptions)가 호출됨"
    

##### iii) 매 `dispatch`마다 구독자에게 **알림이 발생**

- Redux FAQ (Performance):  
    “Redux는 **성공적으로 디스패치된 각 액션마다** 구독자들에게 알림” (여러 액션을 연달아 디스패치하면 알림도 그 횟수만큼 발생) [redux.js.org](https://redux.js.org/faq/performance?utm_source=chatgpt.com)
    

##### +) React‑Redux의 **배칭(batching)** 을 이용해 렌더링 1번 일어나도록 구현 가능

- React‑Redux / Mark Erikson 글:  
    “여러 액션을 한 콜스택에서 디스패치해도, **구독자 통지(mapState 호출)는 액션마다** 일어나지만, React 배칭으로 **렌더는 1번**으로 합쳐질 수 있음” [Mark's Dev Blog](https://blog.isquaredsoftware.com/2020/01/blogged-answers-redux-batching-techniques/?utm_source=chatgpt.com)[GitHub](https://github.com/reduxjs/react-redux/issues/1511?utm_source=chatgpt.com)
    


---

# 2) Jotai는 메모리 구조가 다 WeakMap인가?

**요지:** _핵심 저장소의 키-값 맵이 WeakMap을 중심으로 구성되어 있다_가 정확한 표현.
 “전부 WeakMap”은 아니고, **store 내부에서 atom → 상태**를 매핑하는 주요 자료구조들이 WeakMap

##### 왜 WeakMap인가?

- **GC 친화**: `WeakMap`의 key는 객체만 가능하고, 그 객체(= atom 인스턴스)를 더 이상 참조하지 않으면 엔트리도 자동 제거 → 사용이 끝난 atom 상태가 알아서 회수되어 **메모리 누수 방지**.
    
- **Key로 atom 객체 사용**: `const a = atom(0)`처럼 만든 atom 객체 자체를 키로 쓰면 충돌 없이 빠른 조회가 가능.
    

##### 실제(단순화) 구조 

```
[App]
 └─ <Provider A>
 │    └─ [Store A]
 │        ├─ atomStateMap : WeakMap<Atom, AtomState>
 │        ├─ mountedMap   : WeakMap<Atom, MountedInfo>
 │        └─ (임시) pending/notify 큐 : Set/Map (일반)
 │
 └─ <Provider B>
      └─ [Store B]
           ├─ atomStateMap : WeakMap<Atom, AtomState>
           ├─ mountedMap   : WeakMap<Atom, MountedInfo>
           └─ (임시) pending/notify 큐 : Set/Map (일반)

```


---


# 3) 항상 primitive atom 쓰는 게 좋을까? -> "No." 객체의 변화 빈도에 따라 결정 &

# 4) “구독 범위가 작아서 성능이 좋다”는 게 무슨 말?

##### i ) 작은 컴포넌트(Small components)

관찰하는 atom은 **업데이트가 필요한 애플리케이션의 작은 부분만** 다시 렌더링해야 함
React가 비교해야 할 부분이 적을수록, 렌더 시간이 더 짧아짐

##### ii ) 필요할 때만 렌더링(Render on demand)

일반적으로, 애플리케이션 성능 오버헤드의 주된 원인은  
**불필요하게 다시 렌더링되는 부분**이나 **과도하게 자주 렌더링되는 부분**에서 발생

Jotai는 **데이터를 작은 atom 단위로 쪼개기** 를 권장. 각 atom은 별도로 저장되며, **자신의 값이 변경될 때만** 리렌더를 발생시킴

##### iii )자주 업데이트되는 경우 vs 드물게 업데이트되는 경우

- **자주 업데이트되는 atom**  
  예를 들어, 1초마다 값이 바뀌는 객체를 atom에 담는다면,  
  이 객체의 특정 속성에 `focusAtom`을 사용해도 결국 전체가 동시에 리렌더
  이 경우에는 오버헤드를 추가하지 않고, 새 atom을 만들지 않는 것이 좋음

- **드물게 업데이트되며 속성이 독립적으로 변하는 경우**  
  객체의 속성들이 각각 독립적으로, 그리고 드물게 변경된다면  
  `primitive atom`을 사용해 **불필요한 렌더링을 방지**하는 것이 좋음

---

# 5) Provider는 각각 별도의 store를 생성하나?

"**Yes**" 
Provider를 감싼 서브트리마다 **독립된 store**(= 내부 WeakMap 세트)가 생김
    
- Provider가 없으면 **기본 전역 store** 하나를 씀
    
- 서로 다른 Provider 사이에는 **값이 공유되지 않음**(같은 atom 객체여도 store가 다르면 값은 별개).
    
---

# 6) “쓰기 전용 atom에 왜 get이 있지?” / “getter 안 받기만 하면 쓰기 전용?”

"**getter 를 안 받으면 쓰기 전용. 
setter 로직에 get()이 포함되었는지 유무와는 별개로, 그 atom이 자기 자신의 값을 store에서 직접 읽거나 쓸 수 있는지가 기준**"

- 읽기 전용 atom → store의 다른 atom 값 기반 계산  
- 쓰기 전용 atom → store의 다른 atom 값 변경  
- 읽기+쓰기 atom, 기본 atom → store에서 자기 값 직접 보관

##### 1. **기본 atom**

```ts
import { atom, useAtom, useSetAtom } from 'jotai';

// ① 기본 가격 atom
const priceAtom = atom(100);
```

---

##### 2. **읽기 전용 atom**

```ts
// ② priceAtom 값을 2배로 보여주는 읽기 전용 atom
const doublePriceAtom = atom((get) => get(priceAtom) * 2);
```

호출 예:

```tsx
function ShowDoublePrice() {
  const [doublePrice] = useAtom(doublePriceAtom); // 읽기만 가능
  return <div>2배 가격: {doublePrice}</div>;
}
```

➡ UI에서 `doublePriceAtom`을 읽으면 항상 `priceAtom` 값의 2배가 표시됨

---

##### 3. **쓰기 전용 atom**

```ts
// ③ 할인 적용 버튼 역할 (값은 없음, 쓰기만 가능)
const discountAtom = atom(
  null,
  (get, set, discountAmount) => {
    set(priceAtom, get(priceAtom) - discountAmount);
  }
);
```

호출 예:

```tsx
function DiscountButton() {
  const applyDiscount = useSetAtom(discountAtom); // 쓰기만 가능
  return (
    <button onClick={() => applyDiscount(10)}>
      10원 할인
    </button>
  );
}
```

➡ 버튼을 누르면 `priceAtom`에서 10원이 감소

---

##### 4. **읽기+쓰기 혼합 atom**

```ts
// ④ 읽기와 쓰기 둘 다 가능한 atom
const adjustablePriceAtom = atom(
  (get) => get(priceAtom), // 읽기
  (get, set, newValue) => { // 쓰기
    set(priceAtom, newValue);
  }
);
```

호출 예:

```tsx
function AdjustablePriceInput() {
  const [price, setPrice] = useAtom(adjustablePriceAtom); // 읽기+쓰기 가능
  return (
    <input
      type="number"
      value={price}
      onChange={(e) => setPrice(Number(e.target.value))}
    />
  );
}
```

➡ 입력값이 곧 `priceAtom`을 직접 변경

---

